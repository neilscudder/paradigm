#!/bin/sh

# PARADIGM 0.5.0
# Changelog: Deprecated sshpass, now requires external key authentication.

# Checks for existing ssh tunnels and initiates reverse port-forwarding.
# Usage: [OPTION] PLAYNODE SERVICENAME SERVICEPORT SERVER

# This script runs on a machine we arbitrarily name a PLAYNODE.
# The script connects the playnode to a server we call CONTROL.
# A local service like sshd is given an arbitrary label, the SERVICENAME.
# A local listening port for each service are specified as SERVICEPORT.
# The server should have a jailed user account with basic shell functions.
# At present, authentication is by sshpass using CLI arg credentials. :(

# Copyright 2014 Neil Scudder - neil@neilscudder.com
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

showHelp(){
    cat << EOF
Usage: [OPTION] PLAYNODE SERVICENAME SERVICEPORT SERVER

-h, ?
    Print this usage text.
-u 
    User account on server. Default=paradigm
-p 
    Server account password 
-P 
    SERVERLISTENINGPORT default=22

A playnode is a name to define a group of service ports, usually the hostname.
User account on remote server with shell access required.
Server side flatfile is named portalias-SERVICENAME.
Entries are formatted one playnode per line like this: dummy^32767
Where dummy is the playnode name, and 32767 is the server local port
A server-side script registers new playnodes to new ports in this file.

Examples: 
    paradigm -u user -p password PlaynodeName Shell 22 control.server.com
    paradigm -u user -p password PlaynodeName MPD 6600 control.server.com

EOF
}

# Reset this POSIX variable in case getopts has been used previously in the shell.
OPTIND=1
# Do I need to?:     
CONTROLUSER=""
CONTROLPASS=""

while getopts "hl:u:P:" opt; do
    case "$opt" in
    h)
        showHelp
        exit 0
        ;;
    l)  
        readonly LOGFILE="$OPTARG"
        ;;
    u)  
        readonly CONTROLUSER="$OPTARG"
        ;;
    P)  
        readonly SERVERLISTENINGPORT=$OPTARG
        ;;
    esac
done
shift $((OPTIND-1))
[ "$1" = "--" ] && shift
#echo "CONTROLUSER=$CONTROLUSER, CONTROLPASS=$CONTROLPASS, Leftovers: $@"

readonly PLAYNODE="$1"
readonly SERVICENAME="$2"
readonly SERVICEPORT=$3
readonly CONTROLSERVER="$4"
# Set default if not already
readonly CONTROLUSER="paradigm"
readonly SERVERLISTENINGPORT=42
readonly LOGFILE="/var/lib/paradigm/log.paradigm"


main() {
    local pidFile=/tmp/paradigm-${SERVICENAME}.pid
    if [ -f ${pidFile} ]; then
        logEntry "II - Pid file found for ${SERVICENAME}"
        local pid=$(cat ${pidFile})
        if kill -0 $pid > /dev/null 2>&1; then
            logEntry "II - Tunnel ${pid} found running (${SERVICENAME})."
        else
            logEntry "EE - Tunnel ${pid} not found in process list (${SERVICENAME})."
            rm ${pidFile}
            getPortalias ${SERVICENAME} ${pidFile}
        fi
    else
        logEntry "WW - Pid file not found for ${SERVICENAME}."
        getPortalias ${SERVICENAME} ${pidFile}
    fi
}

logEntry(){
    echo "$(date) ${PLAYNODE} - ${1}" >> $LOGFILE
}

getPortalias() {
    local pidFile=$2
    logEntry "II - getPortalias ${SERVICENAME}."
    local portCmd="cat 'portalias-${SERVICENAME}' | grep '^${PLAYNODE}' | /usr/bin/cut -d^ -f2"
    # Query remote server for remote ports to use for forwarding
    local portalias=$(
    /usr/bin/ssh \
    -q \
    -p ${SERVERLISTENINGPORT} \
    -o StrictHostKeyChecking=no \
    -o ControlMaster=no \
    ${CONTROLUSER}@${CONTROLSERVER} \
    "${portCmd}" \
    2>&1 )
    # TODO: Below does not work. Exit code always 0, probably sshpass wrapper overrides.
    # TODO: Improve error handling for portalias retrieval
    # Below code may work if sshpass removed, key-based auth used instead
    if [ $? -eq 0 ]; then
        establishTunnel ${portalias} "${pidFile}"
    else
        logEntry "EE - Portalias not set. Ssh retrieval failed."
    fi
}

establishTunnel() {
    if [ $# -eq 2 ]; then
        local portalias="$1"
        local pidFile="$2"
        logEntry "II - Portalias ${portalias} being used for local ${SERVICEPORT} ${pidFile}"
    else
        local portalias="NOTSET"
        local pidFile="$1"
        logEntry "EE - Number of args is wrong. getPortalias() failed. ${pidFile}"
        # TODO Considering how serious an error this is, a failover should take effect.
        return
    fi
    
    # Forward $SERVICEPORT over remote $portalias, using $SERVERLISTENINGPORT outbound
    /usr/bin/ssh \
    -q \
    -p ${SERVERLISTENINGPORT} \
    -o StrictHostKeyChecking=no \
    -o ServerAliveCountMax=2 \
    -o ControlMaster=no \
    -o ExitOnForwardFailure=yes \
    -o TCPKeepAlive=yes \
    -o ServerAliveInterval=45 \
    -N \
    -R ${portalias}:localhost:${SERVICEPORT} \
    ${CONTROLUSER}@${CONTROLSERVER} & \
    echo $! > "${pidFile}"
}


# This script requires at least 4 arguments to operate.
# Display usage ifno if insufficient CLI args.
if [ $# -lt 4 ]; then
    showHelp
    exit 1
fi

main # Call the main function once to start

echo "Paradigm for ${SERVICENAME} logged to ${LOGFILE}"

exit 0
