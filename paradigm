#!/bin/bash

# PARADIGM 0.3.1
# Copyright 2014 Neil Scudder neil@neilscudder.com
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


readonly PROGNAME=$(basename $0)
readonly PROGDIR=$(readlink -m $(dirname $0))
readonly ARGS="$@"

if [ $# -lt 2 ]; then
   echo "
Usage: PLAYNODE USER PASSWORD SERVER SERVICENAME SERVICEPORT 
A playnode is a name to define a group of service ports, usually hostname
User account on remote server with shell access required.
Server side flatfile is named portalias-SERVICENAME.
Entries are formatted one playnode per line like this: dummy^32767
Where dummy is the playnode name, and 32767 is the server local port
A server-side script registers new playnodes to new ports in this file.
Ex.: paradigm dummy user password server.com shell 22
Allows the server to access the client port 22 on localhost:32767"
  exit 1
fi

readonly PLAYNODE="$1"
# Server URL and credentials:
readonly CONTROLUSER="$2"
readonly CONTROLPASS="$3"
readonly CONTROLSERVER="$4"
readonly SERVICENAME="$5"
readonly SERVICEPORT=$6
# Playnode needs to reach out over this port
# and the server needs to be listening on it:
# STATEFUL firewalls must open this port to $CONTROLSERVER
readonly SERVERLISTENINGPORT=42
readonly LOGFILE="/var/lib/paradigm/log.paradigm"
# TODO check for SSHPASS dependency

main() {
    tunnelCheck SERVICENAME
}

tunnelCheck() {
    local pidFile=/tmp/paradigm-${SERVICENAME}.pid
        if [ -f ${pidFile} ]; then
                echo "$(date) ${PLAYNODE} - II - Pid file found for ${SERVICENAME}" >> $LOGFILE
                local pid=$(cat ${pidFile})
                if kill -0 $pid > /dev/null 2>&1; then
                        echo "$(date) ${PLAYNODE}- II - Tunnel ${pid} found running (${SERVICENAME})." >> $LOGFILE
                else
                        echo "$(date) ${PLAYNODE}- EE - Tunnel ${pid} not found in process list (${SERVICENAME})." >> $LOGFILE
                        rm ${pidFile}
                        getPortalias ${SERVICENAME} ${pidFile}
                fi
        else
                echo "$(date) ${PLAYNODE}- WW - Pid file not found for ${SERVICENAME}." >> $LOGFILE
                getPortalias ${SERVICENAME} ${pidFile}
        fi
}

getPortalias() {
    local pidFile=$2
    echo "$(date) ${PLAYNODE}- II - getPortalias ${SERVICENAME}." >> $LOGFILE
    local portCmd="cat 'portalias-${SERVICENAME}' | grep '^${PLAYNODE}' | /usr/bin/cut -d^ -f2"
    # Query remote server for remote ports to use for forwarding
    local portalias=$(/usr/bin/sshpass \
        -p${CONTROLPASS} \
        /usr/bin/ssh \
        -q \
        -p ${SERVERLISTENINGPORT} \
        -o StrictHostKeyChecking=no \
        -o ControlMaster=no \
        ${CONTROLUSER}@${CONTROLSERVER} \
        "${portCmd}" \
        2>&1 )
    if [ $? -eq 0 ]; then
        establishTunnel ${portalias} "${pidFile}"
    else
        echo "$(date) ${PLAYNODE}- EE - Portalias not set. Ssh retrieval failed."
    fi
}

establishTunnel() {
        if [ $# -eq 2 ]; then
            local portalias="$1"
            local pidFile="$2"
            echo "$(date) ${PLAYNODE}- II - Portalias ${portalias} being used for ${PLAYNODE} ${pidFile}" >> $LOGFILE
        else
            local portalias="NOTSET"
            local pidFile="$1"
            echo "$(date) ${PLAYNODE}- EE - Number of args is wrong. ${portalias} ${pidfile}" >> $LOGFILE
            # TODO Considering how serious an error this is, a failover should take effect.
            return
        fi
    
        # Forward $localPort over remote $portalias, using $SERVERLISTENINGPORT outbound
        /usr/bin/sshpass \
        -p${CONTROLPASS} \
            /usr/bin/ssh \
            -q \
            -p ${SERVERLISTENINGPORT} \
            -o StrictHostKeyChecking=no \
            -o ServerAliveCountMax=2 \
            -o ControlMaster=no \
            -o ExitOnForwardFailure=yes \
            -o TCPKeepAlive=yes \
            -o ServerAliveInterval=45 \
            -N \
            -R ${portalias}:localhost:${SERVICEPORT} \
            ${CONTROLUSER}@${CONTROLSERVER} & \
            echo $! > "${pidFile}"
}

main # Call the main function once to start

exit 0
