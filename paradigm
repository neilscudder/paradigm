#!/bin/sh
# PARADIGM 0.5.1
# Copyright 2014 Neil Scudder - neil@neilscudder.com
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


#==========# THIS IS AT THE TOP FOR YOU TO READ FIRST #==========#
showHelp() {
  cat << EOF
Usage: [OPTION] PLAYNODE SERVICENAME SERVICEPORT SERVER

-h, ?
  Print this usage text.
-u 
  User account on server. Default=paradigm
-P 
  SERVERLISTENINGPORT default=22

A playnode is a name to define a group of service ports, usually the hostname.
User account on remote server with shell access required.
Server side flatfile is named portalias-SERVICENAME.
Entries are formatted one playnode per line like this: dummy^32767
Where dummy is the playnode name, and 32767 is the server local port
A server-side script registers new playnodes to new ports in this file.

Examples: 
  paradigm PlaynodeName Shell 22 control.server.com
  paradigm -u user -P 443 -l /var/lib/paradigm/log.paradigm PlaynodeName MPD 6600 control.server.com

EOF
}


#==========# PARSE OPTIONS FROM USER INPUT #==========#
# Getopts example from http://stackoverflow.com/a/14203146
# Reset this POSIX variable in case getopts has been used previously in the shell.
OPTIND=1
while getopts "hl:u:P:" opt; do
  case "$opt" in
  h)
    showHelp
    exit 0
    ;;
  l)  
    readonly LOGFILE="$OPTARG"
    ;;
  u)  
    readonly CONTROLUSER="$OPTARG"
    ;;
  P)  
    readonly SERVERLISTENINGPORT=$OPTARG
    ;;
  esac
done
shift $((OPTIND-1))
[ "$1" = "--" ] && shift


#==========# SET GLOBALS AND DEFAULTS #==========#
readonly PLAYNODE="$1"
readonly SERVICENAME="$2"
readonly SERVICEPORT=$3
readonly CONTROLSERVER="$4"
# Set defaults if not already
# example from http://stackoverflow.com/a/13864829/5045643
if [ -z ${CONTROLUSER+x} ]; then readonly CONTROLUSER="paradigm"; fi
if [ -z ${SERVERLISTENINGPORT+x} ]; then readonly SERVERLISTENINGPORT=22; fi
if [ -z ${LOGFILE+x} ]; then readonly LOGFILE="$HOME/log.paradigm"; fi


#==========# CALLED FROM END OF SCRIPT #==========#
main() {
  local pidFile=/tmp/paradigm-${SERVICENAME}.pid
  # Is there evidence that we've already started a tunnel?
  if [ -f ${pidFile} ]; then
    logEntry "II - ${pidFile} found."
    local pid=$(cat ${pidFile})
    # Is the process specified in the pidile found running?
    if kill -0 $pid > /dev/null 2>&1; then
      logEntry "II - Tunnel ${pid} found running (${SERVICENAME})."
    else
      logEntry "EE - Tunnel ${pid} not found in process list (${SERVICENAME})."
      rm ${pidFile}
      portalias=$(getPortalias ${SERVICENAME} ${pidFile})
      establishTunnel ${portalias} "${pidFile}"
    fi
  else
    logEntry "WW - ${pidFile} not found for ${SERVICENAME}."
    portalias=$(getPortalias ${SERVICENAME} ${pidFile})
    establishTunnel ${portalias} "${pidFile}"
  fi
}


logEntry(){
  echo "$(date) ${PLAYNODE} - ${1}" >> $LOGFILE
}


getPortalias() {
  local pidFile=$2
  logEntry "II - getPortalias ${SERVICENAME}."
  local portCmd="cat 'portalias-${SERVICENAME}' | grep '^${PLAYNODE}' | /usr/bin/cut -d^ -f2"
  # Query remote server for remote ports to use for forwarding
  local portalias=$(
    /usr/bin/ssh \
    -q \
    -p ${SERVERLISTENINGPORT} \
    -o StrictHostKeyChecking=no \
    -o ControlMaster=no \
    ${CONTROLUSER}@${CONTROLSERVER} \
    "${portCmd}" \
  2>&1 )
  # If the portalias value is empty then something is wrong.
  if [ -z $portalias ]; then
    logEntry "EE - Portalias not set. Connection failed or playnode not found."
    exit 1
  else
    logEntry "II - Portalias is ${portalias}"
    echo "${portalias}"
  fi
}


establishTunnel() {
  if [ $# -eq 2 ]; then
    local portalias="$1"
    local pidFile="$2"
    logEntry "II - Portalias ${portalias} being used for local ${SERVICEPORT} ${pidFile}"
  else
    local portalias="NOTSET"
    local pidFile="$1"
    logEntry "EE - Number of args is wrong. getPortalias() failed. ${pidFile}"
    # TODO Considering how serious an error this is, a failover should take effect.
    return
  fi
  
  # Forward $SERVICEPORT over remote $portalias, using $SERVERLISTENINGPORT outbound
  /usr/bin/ssh \
  -q \
  -p ${SERVERLISTENINGPORT} \
  -o StrictHostKeyChecking=no \
  -o ServerAliveCountMax=2 \
  -o ControlMaster=no \
  -o ExitOnForwardFailure=yes \
  -o TCPKeepAlive=yes \
  -o ServerAliveInterval=45 \
  -N \
  -R ${portalias}:localhost:${SERVICEPORT} \
  ${CONTROLUSER}@${CONTROLSERVER} & \
  echo $! > "${pidFile}"
}


# This script requires at least 4 arguments to operate.
# Display usage ifno if insufficient CLI args.
if [ $# -lt 4 ]; then
  showHelp
  exit 1
fi

main # Call the main function once to start

echo "Paradigm for ${SERVICENAME} logged to ${LOGFILE}"

exit 0
